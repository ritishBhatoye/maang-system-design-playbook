# Strong Hire vs No Hire Examples

> **实际面试中的答案对比，看出差距。**

---

## 案例 1: 数据库选择

### ❌ No Hire
> "我选择 MongoDB，因为它可以扩展。"

**问题**: 只说"可以扩展"，没有具体理由

---

### ✅ Hire
> "我选择 MongoDB 因为：1) 写入密集型工作负载 2) 需要灵活的 schema 3) 文档结构与业务匹配"

**改进**: 有理由

---

### ✅ Strong Hire
> "我选择 MongoDB 基于以下分析：消息是文档结构，schema 频繁变化。写入 QPS 是 10K，MongoDB 的 WiredTiger 引擎写入性能优于 PostgreSQL。我们接受最终一致性换取性能。如果未来需要强一致，可以考虑事务 API。这是 18 个月内的正确选择。"

**改进**: 量化、tradeoff、演进思路

---

## 案例 2: 缓存设计

### ❌ No Hire
> "我们使用 Redis 做缓存。"

**问题**: 没有细节

---

### ✅ Hire
> "我们使用 Redis 做缓存，采用 Cache-Aside 模式。读取时先查缓存，miss 时查数据库并写入缓存。写操作时让缓存失效。"

**改进**: 有模式

---

### ✅ Strong Hire
> "我们使用 Redis Cluster，数据按 user_id 分片。读写都走缓存，写入后通过延迟删除更新缓存（不一致窗口 < 1 秒）。为防止雪崩，设置随机 TTL 2-5 分钟。为防止穿透，空值也缓存 1 分钟。命中率目标是 95%，需要约 50GB 内存。根据历史数据预估当前 80GB 可以支撑一年。"

**改进**: 完整设计、量化、问题预防

---

## 案例 3: 故障处理

### ❌ No Hire
> "如果数据库挂了，我们有备份。"

**问题**: 太模糊

---

### ✅ Hire
> "如果主数据库挂了，我们有从数据库可以切换。需要 30 秒检测时间，切换后可能丢失少量数据。"

**改进**: 有具体方案

---

### ✅ Strong Hire
> "数据库故障分两层处理：1) 从库自动failover，检测时间 10 秒内，完成后通知应用。2) 如果整个机房挂了，启动跨机房灾备，RTO < 5 分钟，RPO < 1 分钟（通过跨机房同步）。降级策略：如果缓存也失效，允许读取直接打DB，但会限流到正常的 10%。监控包括：延迟上升、错误率、连接池使用率。"

**改进**: 多层、分级、有指标

---

## 案例 4: 规模扩展

### ❌ No Hire
> "我们可以通过增加服务器来扩展。"

**问题**: 没有深度

---

### ✅ Hire
> "我们用水平扩展，加服务器就能增加容量。需要时会做数据分片。"

**改进**: 有方向

---

### ✅ Strong Hire
> "扩展分几个阶段：1) 读写分离解决读扩展 2) 分库分表解决写扩展 3) 最终考虑 NewSQL 如 CockroachDB。目前瓶颈是写，100K QPS 单库不够，我们按 user_id 取模分到 100 个库，每个库 1K QPS。热点用户单独处理。每 6 个月评估是否需要扩容。"

**改进**: 有阶段、有数字、有评估

---

## 案例 5: 一致性选择

### ❌ No Hire
> "我们需要强一致性。"

**问题**: 没有场景分析

---

### ✅ Hire
> "支付需要强一致性，其他可以最终一致。"

**改进**: 有区分

---

### ✅ Strong Hire
> "不同场景不同策略：支付必须强一致，用数据库事务，延迟增加 20ms 可接受。社交 feed 用最终一致，用户发完看到延迟 1 秒可以接受。搜索用弱一致，延迟优先。这里关键是我们要明确区分，而不是一刀切。"

**改进**: 有场景、有权衡、有量化

---

## 总结

| 维度 | Hire | Strong Hire |
|------|------|-------------|
| **技术选择** | 知道用什么 | 知道为什么 + 量化 |
| **Tradeoff** | 简单比较 | 明确放弃什么 |
| **故障** | 有备份 | 多层降级 |
| **扩展** | 加服务器 | 阶段规划 |
| **一致性** | 选一个 | 按场景选 |
